MODULE NRSP77
 	USE NRTYPE
	USE NRUTIL
 	IMPLICIT NONE
 	!-----------------------------------------------------------
 	CONTAINS
	!-----------------------------------------------------------
 	SUBROUTINE DSPRSIN(A,N,Np,THRESH,Nmax,SA,IJA)
  	INTEGER(I4B) :: N, Nmax, Np, IJA(Nmax)
  	INTEGER(I4B) :: I, J, K
  	REAL(DP) :: THRESH
  	COMPLEX(DP) :: A(Np,Np), SA(Nmax)
  	DO J = 1,N
   	SA(J) = A(J,J)
  	END DO
  	IJA(1) = N+2
  	K = N+1
 	DO I = 1,N
   		DO J = 1,N
    			IF (ABS(A(I,J)).GT.THRESH) THEN
    				IF (I.NE.J) THEN
     					K = K+1
      					IF (K.GT.Nmax) THEN
       						WRITE( *, * ) 'Nmax too small. Press Enter to continue'
      						READ( *, * )
      					END IF
      					SA(K) = A(I,J)
      					IJA(K) = j
     				END IF
    			END IF
   		END DO
   		IJA(I+1) = K+1
  	END DO
 	END SUBROUTINE 
 	!-----------------------------------------------------------
 	SUBROUTINE DSPRSAX(SA,IJA,X,B,N)
 	INTEGER(I4B) :: N, IJA(:)
  	INTEGER(I4B) :: I, K
  	COMPLEX(DP) :: B(N), X(N), SA(:)
  	IF (IJA(1).NE.N+2) THEN
   		WRITE( *, * ) 'Mismatched vector and matrix. Press Enter to continue'
   		READ( *, * )
  	END IF
  	DO I = 1,N
   		B(I) = SA(I)*X(I)
   		DO K = IJA(I),IJA(I+1)-1
    			B(I) = B(I)+SA(K)*X(IJA(K))
   		END DO
  	END DO
 	END SUBROUTINE 
 	!-----------------------------------------------------------
 	SUBROUTINE DSPRSTX(SA,IJA,X,B,N)
  	INTEGER(I4B) :: N, IJA(:)
  	INTEGER(I4B) :: I, J, K
  	COMPLEX(DP) :: B(N), X(N), SA(:)
  	IF (IJA(1).NE.N+2) THEN
   		WRITE( *, * ) 'Mismatched vector and matrix. Press Enter to continue'
   		READ( *, * )
  	END IF
  	DO I = 1,N
   		B(I) = SA(I)*X(I)
   		DO K = IJA(I),IJA(I+1)-1
    			J = IJA(K)
    			B(J) = B(J)+SA(K)*X(IJA(K))
   		END DO
  	END DO
 	END SUBROUTINE 
 	!-----------------------------------------------------------
 	SUBROUTINE DSPRSTP(SA,IJA,SB,IJB)
  	INTEGER(I4B) :: IJA(:), IJB(:)
  	COMPLEX(DP) :: SA(:), SB(:), V
  	INTEGER(I4B) :: J, JL, JM, JP, JU, K, M, N2, NOFF, INC, IV
  	N2 = IJA(1)
  	DO J = 1,N2-2
   		SB(J) = SA(J)
  	END DO
  	CALL IINDEXX(IJA(N2-1)-IJA(1),IJA(N2),IJB(N2))
  	JP = 0
  	DO K = IJA(1),IJA(N2-1)-1
   		M = IJB(K)+N2-1
   		SB(K) = SA(M)
   		DO J = JP+1,IJA(M)
    			IJB(J) = K
   		END DO
   		JP = IJA(M)
   		JL = 1
   		JU = N2-1
   		DO WHILE (JU-JL.GT.1) THEN
    			JM = (JU+JL)/2
    			IF (IJA(JM).GT.M) THEN
     				JU = JM
    			ELSE
     				JL = JM
    			END IF
   		END DO
   		IJB(K) = JL
  	END DO
  	DO J = JP+1,N2-1
  		IJB(J) = IJA(N2-1)
  	END DO
  	DO J = 1,N2-2
   		JL = IJB(J+1)-IJB(J)
   		NOFF = IJB(J)-1
   		INC = 1
1  		INC = 3*INC+1
   		IF (INC.LE.JL) GOTO 1
   		WHILE DO (INC.GT.1)
    			INC = INC/3
    			DO K = NOFF+INC+1,NOFF+JL

   	END DO 
 	END SUBROUTINE
 	!-----------------------------------------------------------
 	SUBROUTINE DSPRSTM(SA,IJA,SB,IJB,THRESH,NMAX,SC,IJC)
  	INTEGER(I4B) :: NMAX, IJA(:), IJB(:), IJC(NMAX)
  	REAL(DP) :: THRESH
  	COMPLEX(DP) :: SA(:), SB(:), SC(NMAX), SUMM
  	INTEGER(I4B) :: I, IJMA, IJMB, J, K, MA, MB, MBB
  	IF (IJA(1).NE.IJB(1)) THEN
   		WRITE(*,*) 'Size does not match. Press Enter to continue'
   		READ(*,*)
  	END IF
  	K = IJA(1)
  	IJC(1) = K
  	DO I = 1,IJA(1)-2
  		DO J = 1,IJB(1)-2
    			IF (I.EQ.J) THEN
     				SUMM = SA(I)*SB(J)
    			ELSE
     				SUMM = 0.d0
    			END IF
    			MB = IJB(J)
    			DO MA = IJA(I),IJA(I+1)-1
     				IJMA = IJA(MA)
     				IF (IJMA.EQ.J) THEN
      					SUMM = SUMM+SA(MA)*SB(J)
     				ELSE
      					DO WHILE (MB.LT.IJB(J+1))
       						IJMB = IJB(MB)
       						IF (IJMB.EQ.I) THEN
        						SUMM = SUMM+SA(I)*SB(MB)
        						MB = MB+1
       						ELSEIF (IJMB.LT.IJMA) THEN
        						MB = MB+1
       						ELSEIF (IJMB.EQ.IJMA) THEN
        						SUMM = SUMM+SA(MA)*SB(MB)
        						MB = MB+1
       						END IF
      					END DO
     				END IF
    			END DO
    			DO MBB = MB,IJB(J+1)-1
     				IF (IJB(MBB).EQ.I) THEN
      					SUMM = SUMM + SA(I)*SB(MBB)
     				END IF
    			END DO
    			IF (I.EQ.J) THEN
     				SC(I) = SUMM
    			ELSE IF (ABS(SUMM).GT.THRESH) THEN
     				IF (K.GT. NMAX) THEN
      					WRITE(*,*) 'DSPRSTM : NMAX too small. Press Enter to continue'
      					READ(*,*)
     				END IF
     				SC(K) = SUMM
     				IJC(K) = J
     				K = K+1
    			END IF
   		END DO
   		IJC(I+1) = K
  	END DO
 	END SUBROUTINE 
 	!-----------------------------------------------------------
END MODULE NRSP77

MODULE NRSP90
	USE NRTYPE
	IMPLICIT NONE
 	!-----------------------------------------------------------
	!SPARSE ELEMENTARY FUNCTIONS IN SP AND DP
	!-----------------------------------------------------------
	SUBROUTINE SPRSIN_SP(A,THRESH,SA)
	USE NRTYPE
	USE NRUTIL, ONLY : ARTH,ASSERT_EQ
	IMPLICIT NONE
	COMPLEX(SP), DIMENSION(:,:), INTENT(IN) :: A
	REAL(SP), INTENT(IN) :: THRESH
	TYPE(SPRS2_SP), INTENT(OUT) :: SA
	!Converts a square matrix a to sparse storage format as sa. only elements of a with mag-
	!nitude ≥ thresh are retained.
	INTEGER(I4B) :: N,LEN
	LOGICAL(LGT), DIMENSION(SIZE(A,1),SIZE(A,2)) :: MASK
	N=ASSERT_EQ2(SIZE(A,1),SIZE(A,2),’SPRSIN_SP’)
	MASK=ABS(A)>THRESH
	LEN=COUNT(MASK)
	!How many elements to store?
	ALLOCATE(SA%VAL(LEN),SA%IROW(LEN),SA%JCOL(LEN))
	SA%N=N
	SA%LEN=LEN
	SA%VAL=PACK(A,MASK)
	!Grab the values, row, and column numbers.
	SA%IROW=PACK(SPREAD(ARTH_I(1,1,N),2,N),MASK)
	SA%JCOL=PACK(SPREAD(ARTH_I(1,1,N),1,N),MASK)
	END SUBROUTINE SPRSIN_SP

	SUBROUTINE SPRSIN_DP(A,THRESH,SA)
	USE NRTYPE
	USE NRUTIL, ONLY : ARTH,ASSERT_EQ
	IMPLICIT NONE
	COMPLEX(DP), DIMENSION(:,:), INTENT(IN) :: A
	REAL(DP), INTENT(IN) :: THRESH
	TYPE(SPRS2_DP), INTENT(OUT) :: SA
	INTEGER(I4B) :: N,LEN
	LOGICAL(LGT), DIMENSION(SIZE(A,1),SIZE(A,2)) :: MASK
	N=ASSERT_EQ2(SIZE(A,1),SIZE(A,2),’SPRSIN_DP’)
	MASK=ABS(A)>THRESH
	LEN=COUNT(MASK)
	ALLOCATE(SA%VAL(LEN),SA%IROW(LEN),SA%JCOL(LEN))
	SA%N=N
	SA%LEN=LEN
	SA%VAL=PACK(A,MASK)
	SA%IROW=PACK(SPREAD(ARTH_I(1,1,N),2,N),MASK)
	SA%JCOL=PACK(SPREAD(ARTH_I(1,1,N),1,N),MASK)
	END SUBROUTINE SPRSIN_DP
 	!-----------------------------------------------------------	
	SUBROUTINE SPRSAX_SP(SA,X,B)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ,SCATTER_ADD
	IMPLICIT NONE
	TYPE(SPRS2_SP), INTENT(IN) :: SA
	COMPLEX(SP), DIMENSION (:), INTENT(IN) :: X
	COMPLEX(SP), DIMENSION (:), INTENT(OUT) :: B
	!Multiply a matrix sa in sparse matrix format by a vector x, giving a vector b.
	INTEGER(I4B) :: NDUM
	NDUM=ASSERT_EQ3(SA%N,SIZE(X),SIZE(B),’SPRSAX_SP’)
	B=0.0_SP
	CALL SCATTER_ADD(B,SA%VAL*X(SA%JCOL),SA%IROW)
	!Each sparse matrix entry adds a term to some component of b.
	END SUBROUTINE SPRSAX_SP

	SUBROUTINE SPRSAX_DP(SA,X,B)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ,SCATTER_ADD
	IMPLICIT NONE
	TYPE(SPRS2_DP), INTENT(IN) :: SA
	COMPLEX(DP), DIMENSION (:), INTENT(IN) :: X
	COMPLEX(DP), DIMENSION (:), INTENT(OUT) :: B
	INTEGER(I4B) :: NDUM
	NDUM=ASSERT_EQ3(SA%N,SIZE(X),SIZE(B),’SPRSAX_DP’)
	B=0.0_DP
	CALL SCATTER_ADD(B,SA%VAL*X(SA%JCOL),SA%IROW)
	END SUBROUTINE SPRSAX_DP
 	!-----------------------------------------------------------
	SUBROUTINE SPRSTX_SP(SA,X,B)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ,SCATTER_ADD
	IMPLICIT NONE
	TYPE(SPRS2_SP), INTENT(IN) :: SA
	COMPLEX(SP), DIMENSION (:), INTENT(IN) :: X
	COMPLEX(SP), DIMENSION (:), INTENT(OUT) :: B
	!Multiply the transpose of a matrix sa in sparse matrix format by a vector x, giving a vector b.
	INTEGER(I4B) :: NDUM
	NDUM=ASSERT_EQ3(SA%N,SIZE(X),SIZE(B),’SPRSTX_SP’)
	B=0.0_SP
	CALL SCATTER_ADD_C(B,SA%VAL*X(SA%IROW),SA%JCOL)
	!Each sparse matrix entry adds a term to some component of b.
	END SUBROUTINE SPRSTX_SP

	SUBROUTINE SPRSTX_DP(SA,X,B)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ,SCATTER_ADD
	IMPLICIT NONE
	TYPE(SPRS2_DP), INTENT(IN) :: SA
	COMPLEX(DP), DIMENSION (:), INTENT(IN) :: X
	COMPLEX(DP), DIMENSION (:), INTENT(OUT) :: B
	INTEGER(I4B) :: NDUM
	NDUM=ASSERT_EQ3(SA%N,SIZE(X),SIZE(B),’SPRSTX_DP’)
	B=0.0_DP
	CALL SCATTER_ADD_C(B,SA%VAL*X(SA%IROW),SA%JCOL)
	END SUBROUTINE SPRSTX_DP
 	!-----------------------------------------------------------
	SUBROUTINE SPRSTP(SA)
	USE NRTYPE
	IMPLICIT NONE
	TYPE(SPRS2_SP), INTENT(INOUT) :: SA
	!Replaces sa, in sparse matrix format, by its transpose.
	INTEGER(I4B), DIMENSION(:), POINTER :: TEMP
	TEMP=>SA%IROW
	!We need only swap the row and column pointers.
	SA%IROW=>SA%JCOL
	SA%JCOL=>TEMP
	END SUBROUTINE SPRSTP
	!-----------------------------------------------------------
	SUBROUTINE SPRSDIAG_SP(SA,B)
	USE NRTYPE
	USE NRUTIL, ONLY : ARRAY_COPY,ASSERT_EQ
	IMPLICIT NONE
	TYPE(SPRS2_SP), INTENT(IN) :: SA
	COMPLEX(SP), DIMENSION(:), INTENT(OUT) :: B
	!EXTRACTS THE DIAGONAL OF A MATRIX SA IN SPARSE MATRIX FORMAT INTO A VECTOR B.
	COMPLEX(SP), DIMENSION(SIZE(B)) :: VAL
	INTEGER(I4B) :: K,L,NDUM,NERR
	INTEGER(I4B), DIMENSION(SIZE(B)) :: I
	LOGICAL(LGT), DIMENSION(:), ALLOCATABLE :: MASK
	NDUM=ASSERT_EQ2(SA%N,SIZE(B),’SPRSDIAG_SP’)
	L=SA%LEN
	ALLOCATE(MASK(L))
	MASK = (SA%IROW(1:L) == SA%JCOL(1:L))			!FIND DIAGONAL ELEMENTS.
	CALL ARRAY_COPY_C(PACK(SA%VAL(1:L),MASK),VAL,K,NERR) 	!GRAB THE VALUES...
	I(1:K)=PACK(SA%IROW(1:L),MASK) 				!...AND THEIR LOCATIONS.
	DEALLOCATE(MASK)
	B=0.0							!ZERO B BECAUSE ZERO VALUES NOT STORED IN SA.
	B(I(1:K))=VAL(1:K)					!SCATTER VALUES INTO CORRECT SLOTS.
	END SUBROUTINE SPRSDIAG_SP

	SUBROUTINE SPRSDIAG_DP(SA,B)
	USE NRTYPE
	USE NRUTIL, ONLY : ARRAY_COPY,ASSERT_EQ
	IMPLICIT NONE
	TYPE(SPRS2_DP), INTENT(IN) :: SA
	COMPLEX(DP), DIMENSION(:), INTENT(OUT) :: B
	COMPLEX(DP), DIMENSION(SIZE(B)) :: VAL
	INTEGER(I4B) :: K,L,NDUM,NERR
	INTEGER(I4B), DIMENSION(SIZE(B)) :: I
	LOGICAL(LGT), DIMENSION(:), ALLOCATABLE :: MASK
	NDUM=ASSERT_EQ2(SA%N,SIZE(B),’SPRSDIAG_DP’)
	L=SA%LEN
	ALLOCATE(MASK(L))
	MASK = (SA%IROW(1:L) == SA%JCOL(1:L))
	CALL ARRAY_COPY_C(PACK(SA%VAL(1:L),MASK),VAL,K,NERR)
	I(1:K)=PACK(SA%IROW(1:L),MASK)
	DEALLOCATE(MASK)
	B=0.0
	B(I(1:K))=VAL(1:K)
	END SUBROUTINE SPRSDIAG_DP
	!-----------------------------------------------------------
	!LINBCG AUXILIARY ROUTINES
	!-----------------------------------------------------------
	FUNCTION SNRM(SX,ITOL)
	USE NRTYPE
	IMPLICIT NONE
	COMPLEX(DP), DIMENSION(:), INTENT(IN) :: SX
	INTEGER(I4B), INTENT(IN) :: ITOL
	REAL(DP) :: SNRM
	!COMPUTE ONE OF TWO NORMS FOR A VECTOR SX, AS SIGNALED BY ITOL. USED BY LINBCG.
	IF (ITOL <= 3) THEN
		SNRM=SQRT(DOT_PRODUCT(SX,SX))		!VECTOR MAGNITUDE NORM.
	ELSE
		SNRM=MAXVAL(ABS(SX))			!LARGEST COMPONENT NORM.
	END IF
	END FUNCTION SNRM

	SUBROUTINE ATIMES(SA,X,R,ITRNSP)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ
	!USE NR, ONLY : SPRSAX,SPRSTX
	!DOUBLE PRECISION VERSIONS OF SPRSAX AND SPRSTX.
	!USE XLINBCG_DATA
	!THE MATRIX IS ACCESSED THROUGH THIS MODULE.
	TYPE(SPRS2_DP), INTENT(IN) :: SA
	COMPLEX(DP), DIMENSION(:), INTENT(IN) :: X
	COMPLEX(DP), DIMENSION(:), INTENT(OUT) :: R
	INTEGER(I4B), INTENT(IN) :: ITRNSP
	INTEGER(I4B) :: N
	N=ASSERT_EQ2(SIZE(X),SIZE(R),’ATIMES’)
	IF (ITRNSP == 0) THEN
		CALL SPRSAX(SA,X,R)
	ELSE
		CALL SPRSTX(SA,X,R)
	END IF
	END SUBROUTINE ATIMES

	SUBROUTINE ASOLVE(SA,B,X,ITRNSP)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ,NRERROR
	!USE NR, ONLY : SPRSDIAG
	!DOUBLE PRECISION VERSION OF SPRSDIAG.
	!USE XLINBCG_DATA
	!THE MATRIX IS ACCESSED THROUGH THIS MODULE.
	TYPE(SPRS2_DP), INTENT(IN) :: SA
	COMPLEX(DP), DIMENSION(:), INTENT(IN) :: B
	COMPLEX(DP), DIMENSION(:), INTENT(OUT) :: X
	INTEGER(I4B), INTENT(IN) :: ITRNSP
	INTEGER(I4B) :: NDUM
	NDUM=ASSERT_EQ2(SIZE(B),SIZE(X),’ASOLVE’)
	CALL SPRSDIAG(SA,X)
	!THE MATRIX A IS TAKEN TO BE THE DIAGONAL PART OF A. SINCE THE TRANSPOSE MATRIX HAS THE SAME
	!DIAGONAL, THE FLAG ITRNSP IS NOT USED.
	IF (ANY(X == 0.0)) CALL NRERROR(’ASOLVE: SINGULAR DIAGONAL MATRIX’)
	X=B/X
	END SUBROUTINE ASOLVE
 	!-----------------------------------------------------------
	!MAIN SPARSE BCG SOLVER
	!-----------------------------------------------------------
	SUBROUTINE LINBCG(SA,B,X,ITOL,TOL,ITMAX,ITER,ERR)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ,NRERROR
	IMPLICIT NONE
	!DOUBLE PRECISION IS A GOOD IDEA IN THIS ROUTINE.
	COMPLEX(DP), DIMENSION(:), INTENT(IN) :: B
	COMPLEX(DP), DIMENSION(:), INTENT(INOUT) :: X
	TYPE(SPRS2_DP), INTENT(IN) :: SA
	INTEGER(I4B), INTENT(IN) :: ITOL,ITMAX
	REAL(DP), INTENT(IN) :: TOL
	INTEGER(I4B), INTENT(OUT) :: ITER
	REAL(DP), INTENT(OUT) :: ERR
	REAL(DP), PARAMETER :: EPS=1.0E-14_DP
	!SOLVES A · X = B FOR X, GIVEN B OF THE SAME LENGTH, BY THE ITERATIVE BICONJUGATE GRADIENT
	!METHOD. ON INPUT X SHOULD BE SET TO AN INITIAL GUESS OF THE SOLUTION (OR ALL ZEROS); ITOL IS
	!1,2,3, OR 4, SPECIFYING WHICH CONVERGENCE TEST IS APPLIED (SEE TEXT); ITMAX IS THE MAXIMUM
	!NUMBER OF ALLOWED ITERATIONS; AND TOL IS THE DESIRED CONVERGENCE TOLERANCE. ON OUTPUT, X
	!IS RESET TO THE IMPROVED SOLUTION, ITER IS THE NUMBER OF ITERATIONS ACTUALLY TAKEN, AND ERR
	!IS THE ESTIMATED ERROR. THE MATRIX A IS REFERENCED ONLY THROUGH THE USER-SUPPLIED ROUTINES
	!ATIMES, WHICH COMPUTES THE PRODUCT OF EITHER A OR ITS TRANSPOSE ON A VECTOR; AND ASOLVE,
	!WHICH SOLVES A · X = B OR A · X = B FOR SOME PRECONDITIONER MATRIX A (POSSIBLY THE TRIVIAL
	!DIAGONAL PART OF A).
	INTEGER(I4B) :: N
	COMPLEX(DP) :: AK,AKDEN,BK,BKDEN,BKNUM,BNRM,DXNRM,XNRM,ZM1NRM,ZNRM
	COMPLEX(DP), DIMENSION(SIZE(B)) :: P,PP,R,RR,Z,ZZ
	N=ASSERT_EQ2(SIZE(B),SIZE(X),’LINBCG’)
	ITER=0
	CALL ATIMES(SA,X,R,0)
	!CALCULATE INITIAL RESIDUAL. INPUT TO ATIMES IS
	!X(1:N), OUTPUT IS R(1:N); THE FINAL 0 INDICATES THAT THE MATRIX (NOT ITS TRANS-POSE) IS TO 
	!BE USED.
	R=B-R
	RR=R
	CALL ATIMES(SA,R,RR,0) 	!UNCOMMENT THIS FOR THE “MINIMUM RESIDUAL” VARIANT OF THE ALGORITHM.
	!INPUT TO ASOLVE IS R(1:N), OUTPUT IS Z(1:N); THE FINAL 0 INDICATES THAT THE MATRIX A
	!(NOT ITS TRANSPOSE) IS TO BE USED.
	SELECT CASE(ITOL)	!CALCULATE NORMS FOR USE IN STOPPING CRITERION AND INITIALIZE Z.
		CASE(1)
			BNRM=SNRM(B,ITOL)
			CALL ASOLVE(SA,R,Z,0)
		CASE(2)
			CALL ASOLVE(SA,B,Z,0)
			BNRM=SNRM(Z,ITOL)
			CALL ASOLVE(SA,R,Z,0)
		CASE(3:4)
			CALL ASOLVE(SA,B,Z,0)
			BNRM=SNRM(Z,ITOL)
			CALL ASOLVE(SA,R,Z,0)
			ZNRM=SNRM(Z,ITOL)
		CASE DEFAULT
			CALL NRERROR(’ILLEGAL ITOL IN LINBCG’)
	END SELECT
	DO					!MAIN LOOP.
		IF (ITER > ITMAX) EXIT
			ITER=ITER+1
			CALL ASOLVE(SA,RR,ZZ,1)	!FINAL 1 INDICATES USE OF TRANSPOSE MATRIX A .
			BKNUM=DOT_PRODUCT(Z,RR)	!CALCULATE COEFFICIENT BK AND DIRECTION VECTORS P AND PP.
		IF (ITER == 1) THEN
			P=Z
			PP=ZZ
		ELSE
			BK=BKNUM/BKDEN
			P=BK*P+Z
			PP=BK*PP+ZZ
		END IF
		BKDEN=BKNUM 		!CALCULATE COEFFICIENT AK, NEW ITERATE X, NEW RESIDUALS R AND RR.
		CALL ATIMES(SA,P,Z,0)
		AKDEN=DOT_PRODUCT(Z,PP)
		AK=BKNUM/AKDEN
		CALL ATIMES(SA,PP,ZZ,1)
		X=X+AK*P
		R=R-AK*Z
		RR=RR-AK*ZZ
		CALL ASOLVE(SA,R,Z,0)	!SOLVE A ·Z = R AND CHECK STOPPING CRITERION.
		SELECT CASE(ITOL)
			CASE(1)
				ERR=SNRM(R,ITOL)/BNRM
			CASE(2)
				ERR=SNRM(Z,ITOL)/BNRM
			CASE(3:4)
				ZM1NRM=ZNRM
				ZNRM=SNRM(Z,ITOL)
				IF (ABS(ZM1NRM-ZNRM) > EPS*ZNRM) THEN
					DXNRM=ABS(AK)*SNRM(P,ITOL)
					ERR=ZNRM/ABS(ZM1NRM-ZNRM)*DXNRM
				ELSE
					ERR=ZNRM/BNRM
					CYCLE 	!ERROR MAY NOT BE ACCURATE, SO LOOP AGAIN.
				END IF
				XNRM=SNRM(X,ITOL)
				IF (ERR <= 0.5_DP*XNRM) THEN
					ERR=ERR/XNRM
				ELSE
					ERR=ZNRM/BNRM
					CYCLE 	!ERROR MAY NOT BE ACCURATE, SO LOOP AGAIN.

				END IF
		END SELECT
		WRITE (*,*) ’ ITER=’,ITER,’ ERR=’,ERR
		IF (ERR <= TOL) EXIT
	END DO
	END SUBROUTINE LINBCG
	!-----------------------------------------------------------
END MODULE NRSP90

