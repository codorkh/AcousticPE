MODULE NRSP90
	USE NRTYPE
	USE NRUTIL
	IMPLICIT NONE
 	!-----------------------------------------------------------
	!SPARSE ELEMENTARY FUNCTIONS IN SP AND DP
	!-----------------------------------------------------------
	SUBROUTINE SPRSIN_SP(A,THRESH,SA) 
	USE NRTYPE
	USE NRUTIL, ONLY : ARTH,ASSERT_EQ
	IMPLICIT NONE
	COMPLEX(SP), DIMENSION(:,:), INTENT(IN) :: A
	REAL(SP), INTENT(IN) :: THRESH
	TYPE(SPRS2_SP), INTENT(OUT) :: SA
	!Converts a square matrix a to sparse storage format as sa. only elements of a with mag-
	!nitude ≥ thresh are retained.
	INTEGER(I4B) :: N,NELT
	LOGICAL(LGT), DIMENSION(SIZE(A,1),SIZE(A,2)) :: MASK
	N=ASSERT_EQ2(SIZE(A,1),SIZE(A,2),’SPRSIN_SP’)
	MASK=ABS(A)>THRESH
	NELT=COUNT(MASK)
	!How many elements to store?
	ALLOCATE(SA%VAL(NELT),SA%IROW(NELT),SA%JCOL(NELT))
	SA%N=N
	SA%NELT=NELT
	SA%VAL=PACK(A,MASK)
	!Grab the values, row, and column numbers.
	SA%IROW=PACK(SPREAD(ARTH_I(1,1,N),2,N),MASK)
	SA%JCOL=PACK(SPREAD(ARTH_I(1,1,N),1,N),MASK)
	END SUBROUTINE SPRSIN_SP

	SUBROUTINE SPRSIN_DP(A,THRESH,SA)
	USE NRTYPE
	USE NRUTIL, ONLY : ARTH,ASSERT_EQ
	IMPLICIT NONE
	COMPLEX(DP), DIMENSION(:,:), INTENT(IN) :: A
	REAL(DP), INTENT(IN) :: THRESH
	TYPE(SPRS2_DP), INTENT(OUT) :: SA
	INTEGER(I4B) :: N,NELT
	LOGICAL(LGT), DIMENSION(SIZE(A,1),SIZE(A,2)) :: MASK
	N=ASSERT_EQ2(SIZE(A,1),SIZE(A,2),’SPRSIN_DP’)
	MASK=ABS(A)>THRESH
	NELT=COUNT(MASK)
	ALLOCATE(SA%VAL(NELT),SA%IROW(NELT),SA%JCOL(NELT))
	SA%N=N
	SA%NELT=NELT
	SA%VAL=PACK(A,MASK)
	SA%IROW=PACK(SPREAD(ARTH_I(1,1,N),2,N),MASK)
	SA%JCOL=PACK(SPREAD(ARTH_I(1,1,N),1,N),MASK)
	END SUBROUTINE SPRSIN_DP
 	!-----------------------------------------------------------	
	SUBROUTINE SPRSAX_SP(SA,X,B)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ,SCATTER_ADD
	IMPLICIT NONE
	TYPE(SPRS2_SP), INTENT(IN) :: SA
	COMPLEX(SP), DIMENSION (:), INTENT(IN) :: X
	COMPLEX(SP), DIMENSION (:), INTENT(OUT) :: B
	!Multiply a matrix sa in sparse matrix format by a vector x, giving a vector b.
	INTEGER(I4B) :: NDUM
	NDUM=ASSERT_EQ3(SA%N,SIZE(X),SIZE(B),’SPRSAX_SP’)
	B=0.0_SP
	CALL SCATTER_ADD(B,SA%VAL*X(SA%JCOL),SA%IROW)
	!Each sparse matrix entry adds a term to some component of b.
	END SUBROUTINE SPRSAX_SP

	SUBROUTINE SPRSAX_DP(SA,X,B)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ,SCATTER_ADD
	IMPLICIT NONE
	TYPE(SPRS2_DP), INTENT(IN) :: SA
	COMPLEX(DP), DIMENSION (:), INTENT(IN) :: X
	COMPLEX(DP), DIMENSION (:), INTENT(OUT) :: B
	INTEGER(I4B) :: NDUM
	NDUM=ASSERT_EQ3(SA%N,SIZE(X),SIZE(B),’SPRSAX_DP’)
	B=0.0_DP
	CALL SCATTER_ADD(B,SA%VAL*X(SA%JCOL),SA%IROW)
	END SUBROUTINE SPRSAX_DP
 	!-----------------------------------------------------------
	SUBROUTINE SPRSTX_SP(SA,X,B)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ,SCATTER_ADD
	IMPLICIT NONE
	TYPE(SPRS2_SP), INTENT(IN) :: SA
	COMPLEX(SP), DIMENSION (:), INTENT(IN) :: X
	COMPLEX(SP), DIMENSION (:), INTENT(OUT) :: B
	!Multiply the transpose of a matrix sa in sparse matrix format by a vector x, giving a vector b.
	INTEGER(I4B) :: NDUM
	NDUM=ASSERT_EQ3(SA%N,SIZE(X),SIZE(B),’SPRSTX_SP’)
	B=0.0_SP
	CALL SCATTER_ADD_C(B,SA%VAL*X(SA%IROW),SA%JCOL)
	!Each sparse matrix entry adds a term to some component of b.
	END SUBROUTINE SPRSTX_SP

	SUBROUTINE SPRSTX_DP(SA,X,B)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ,SCATTER_ADD
	IMPLICIT NONE
	TYPE(SPRS2_DP), INTENT(IN) :: SA
	COMPLEX(DP), DIMENSION (:), INTENT(IN) :: X
	COMPLEX(DP), DIMENSION (:), INTENT(OUT) :: B
	INTEGER(I4B) :: NDUM
	NDUM=ASSERT_EQ3(SA%N,SIZE(X),SIZE(B),’SPRSTX_DP’)
	B=0.0_DP
	CALL SCATTER_ADD_C(B,SA%VAL*X(SA%IROW),SA%JCOL)
	END SUBROUTINE SPRSTX_DP
 	!-----------------------------------------------------------
	SUBROUTINE SPRSTP(SA)
	USE NRTYPE
	IMPLICIT NONE
	TYPE(SPRS2_SP), INTENT(INOUT) :: SA
	!Replaces sa, in sparse matrix format, by its transpose.
	INTEGER(I4B), DIMENSION(:), POINTER :: TEMP
	TEMP=>SA%IROW
	!We need only swap the row and column pointers.
	SA%IROW=>SA%JCOL
	SA%JCOL=>TEMP
	END SUBROUTINE SPRSTP
	!-----------------------------------------------------------
	SUBROUTINE SPRSDIAG_SP(SA,B)
	USE NRTYPE
	USE NRUTIL, ONLY : ARRAY_COPY,ASSERT_EQ
	IMPLICIT NONE
	TYPE(SPRS2_SP), INTENT(IN) :: SA
	COMPLEX(SP), DIMENSION(:), INTENT(OUT) :: B
	!EXTRACTS THE DIAGONAL OF A MATRIX SA IN SPARSE MATRIX FORMAT INTO A VECTOR B.
	COMPLEX(SP), DIMENSION(SIZE(B)) :: VAL
	INTEGER(I4B) :: K,L,NDUM,NERR
	INTEGER(I4B), DIMENSION(SIZE(B)) :: I
	LOGICAL(LGT), DIMENSION(:), ALLOCATABLE :: MASK
	NDUM=ASSERT_EQ2(SA%N,SIZE(B),’SPRSDIAG_SP’)
	L=SA%NELT
	ALLOCATE(MASK(L))
	MASK = (SA%IROW(1:L) == SA%JCOL(1:L))			!FIND DIAGONAL ELEMENTS.
	CALL ARRAY_COPY_C(PACK(SA%VAL(1:L),MASK),VAL,K,NERR) 	!GRAB THE VALUES...
	I(1:K)=PACK(SA%IROW(1:L),MASK) 				!...AND THEIR LOCATIONS.
	DEALLOCATE(MASK)
	B=0.0							!ZERO B BECAUSE ZERO VALUES NOT STORED IN SA.
	B(I(1:K))=VAL(1:K)					!SCATTER VALUES INTO CORRECT SLOTS.
	END SUBROUTINE SPRSDIAG_SP

	SUBROUTINE SPRSDIAG_DP(SA,B)
	USE NRTYPE
	USE NRUTIL, ONLY : ARRAY_COPY,ASSERT_EQ
	IMPLICIT NONE
	TYPE(SPRS2_DP), INTENT(IN) :: SA
	COMPLEX(DP), DIMENSION(:), INTENT(OUT) :: B
	COMPLEX(DP), DIMENSION(SIZE(B)) :: VAL
	INTEGER(I4B) :: K,L,NDUM,NERR
	INTEGER(I4B), DIMENSION(SIZE(B)) :: I
	LOGICAL(LGT), DIMENSION(:), ALLOCATABLE :: MASK
	NDUM=ASSERT_EQ2(SA%N,SIZE(B),’SPRSDIAG_DP’)
	L=SA%NELT
	ALLOCATE(MASK(L))
	MASK = (SA%IROW(1:L) == SA%JCOL(1:L))
	CALL ARRAY_COPY_C(PACK(SA%VAL(1:L),MASK),VAL,K,NERR)
	I(1:K)=PACK(SA%IROW(1:L),MASK)
	DEALLOCATE(MASK)
	B=0.0
	B(I(1:K))=VAL(1:K)
	END SUBROUTINE SPRSDIAG_DP
	!-----------------------------------------------------------
	!LINBCG AUXILIARY ROUTINES
	!-----------------------------------------------------------
	FUNCTION SNRM(SX,ITOL)
	USE NRTYPE
	IMPLICIT NONE
	COMPLEX(DP), DIMENSION(:), INTENT(IN) :: SX
	INTEGER(I4B), INTENT(IN) :: ITOL
	REAL(DP) :: SNRM
	!COMPUTE ONE OF TWO NORMS FOR A VECTOR SX, AS SIGNALED BY ITOL. USED BY LINBCG.
	IF (ITOL <= 3) THEN
		SNRM=SQRT(DOT_PRODUCT(SX,SX))		!VECTOR MAGNITUDE NORM.
	ELSE
		SNRM=MAXVAL(ABS(SX))			!LARGEST COMPONENT NORM.
	END IF
	END FUNCTION SNRM

	SUBROUTINE ATIMES(SA,X,R,ITRNSP)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ
	!USE NR, ONLY : SPRSAX,SPRSTX
	!DOUBLE PRECISION VERSIONS OF SPRSAX AND SPRSTX.
	!USE XLINBCG_DATA
	!THE MATRIX IS ACCESSED THROUGH THIS MODULE.
	TYPE(SPRS2_DP), INTENT(IN) :: SA
	COMPLEX(DP), DIMENSION(:), INTENT(IN) :: X
	COMPLEX(DP), DIMENSION(:), INTENT(OUT) :: R
	INTEGER(I4B), INTENT(IN) :: ITRNSP
	INTEGER(I4B) :: N
	N=ASSERT_EQ2(SIZE(X),SIZE(R),’ATIMES’)
	IF (ITRNSP == 0) THEN
		CALL SPRSAX(SA,X,R)
	ELSE
		CALL SPRSTX(SA,X,R)
	END IF
	END SUBROUTINE ATIMES

	SUBROUTINE ASOLVE(SA,B,X,ITRNSP)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ,NRERROR
	!USE NR, ONLY : SPRSDIAG
	!DOUBLE PRECISION VERSION OF SPRSDIAG.
	!USE XLINBCG_DATA
	!THE MATRIX IS ACCESSED THROUGH THIS MODULE.
	TYPE(SPRS2_DP), INTENT(IN) :: SA
	COMPLEX(DP), DIMENSION(:), INTENT(IN) :: B
	COMPLEX(DP), DIMENSION(:), INTENT(OUT) :: X
	INTEGER(I4B), INTENT(IN) :: ITRNSP
	INTEGER(I4B) :: NDUM
	NDUM=ASSERT_EQ2(SIZE(B),SIZE(X),’ASOLVE’)
	CALL SPRSDIAG(SA,X)
	!THE MATRIX A IS TAKEN TO BE THE DIAGONAL PART OF A. SINCE THE TRANSPOSE MATRIX HAS THE SAME
	!DIAGONAL, THE FLAG ITRNSP IS NOT USED.
	IF (ANY(X == 0.0)) CALL NRERROR(’ASOLVE: SINGULAR DIAGONAL MATRIX’)
	X=B/X
	END SUBROUTINE ASOLVE
 	!-----------------------------------------------------------
	!MAIN SPARSE BCG SOLVER
	!-----------------------------------------------------------
	SUBROUTINE LINBCG(SA,B,X,ITOL,TOL,ITMAX,ITER,ERR)
	USE NRTYPE
	USE NRUTIL, ONLY : ASSERT_EQ,NRERROR
	IMPLICIT NONE
	!DOUBLE PRECISION IS A GOOD IDEA IN THIS ROUTINE.
	COMPLEX(DP), DIMENSION(:), INTENT(IN) :: B
	COMPLEX(DP), DIMENSION(:), INTENT(INOUT) :: X
	TYPE(SPRS2_DP), INTENT(IN) :: SA
	INTEGER(I4B), INTENT(IN) :: ITOL,ITMAX
	REAL(DP), INTENT(IN) :: TOL
	INTEGER(I4B), INTENT(OUT) :: ITER
	REAL(DP), INTENT(OUT) :: ERR
	REAL(DP), PARAMETER :: EPS=1.0E-14_DP
	!SOLVES A · X = B FOR X, GIVEN B OF THE SAME LENGTH, BY THE ITERATIVE BICONJUGATE GRADIENT
	!METHOD. ON INPUT X SHOULD BE SET TO AN INITIAL GUESS OF THE SOLUTION (OR ALL ZEROS); ITOL IS
	!1,2,3, OR 4, SPECIFYING WHICH CONVERGENCE TEST IS APPLIED (SEE TEXT); ITMAX IS THE MAXIMUM
	!NUMBER OF ALLOWED ITERATIONS; AND TOL IS THE DESIRED CONVERGENCE TOLERANCE. ON OUTPUT, X
	!IS RESET TO THE IMPROVED SOLUTION, ITER IS THE NUMBER OF ITERATIONS ACTUALLY TAKEN, AND ERR
	!IS THE ESTIMATED ERROR. THE MATRIX A IS REFERENCED ONLY THROUGH THE USER-SUPPLIED ROUTINES
	!ATIMES, WHICH COMPUTES THE PRODUCT OF EITHER A OR ITS TRANSPOSE ON A VECTOR; AND ASOLVE,
	!WHICH SOLVES A · X = B OR A · X = B FOR SOME PRECONDITIONER MATRIX A (POSSIBLY THE TRIVIAL
	!DIAGONAL PART OF A).
	INTEGER(I4B) :: N
	COMPLEX(DP) :: AK,AKDEN,BK,BKDEN,BKNUM,BNRM,DXNRM,XNRM,ZM1NRM,ZNRM
	COMPLEX(DP), DIMENSION(SIZE(B)) :: P,PP,R,RR,Z,ZZ
	N=ASSERT_EQ2(SIZE(B),SIZE(X),’LINBCG’)
	ITER=0
	CALL ATIMES(SA,X,R,0)
	!CALCULATE INITIAL RESIDUAL. INPUT TO ATIMES IS
	!X(1:N), OUTPUT IS R(1:N); THE FINAL 0 INDICATES THAT THE MATRIX (NOT ITS TRANS-POSE) IS TO 
	!BE USED.
	R=B-R
	RR=R
	CALL ATIMES(SA,R,RR,0) 	!UNCOMMENT THIS FOR THE “MINIMUM RESIDUAL” VARIANT OF THE ALGORITHM.
	!INPUT TO ASOLVE IS R(1:N), OUTPUT IS Z(1:N); THE FINAL 0 INDICATES THAT THE MATRIX A
	!(NOT ITS TRANSPOSE) IS TO BE USED.
	SELECT CASE(ITOL)	!CALCULATE NORMS FOR USE IN STOPPING CRITERION AND INITIALIZE Z.
		CASE(1)
			BNRM=SNRM(B,ITOL)
			CALL ASOLVE(SA,R,Z,0)
		CASE(2)
			CALL ASOLVE(SA,B,Z,0)
			BNRM=SNRM(Z,ITOL)
			CALL ASOLVE(SA,R,Z,0)
		CASE(3:4)
			CALL ASOLVE(SA,B,Z,0)
			BNRM=SNRM(Z,ITOL)
			CALL ASOLVE(SA,R,Z,0)
			ZNRM=SNRM(Z,ITOL)
		CASE DEFAULT
			CALL NRERROR(’ILLEGAL ITOL IN LINBCG’)
	END SELECT
	DO					!MAIN LOOP.
		IF (ITER > ITMAX) EXIT
			ITER=ITER+1
			CALL ASOLVE(SA,RR,ZZ,1)	!FINAL 1 INDICATES USE OF TRANSPOSE MATRIX A .
			BKNUM=DOT_PRODUCT(Z,RR)	!CALCULATE COEFFICIENT BK AND DIRECTION VECTORS P AND PP.
		IF (ITER == 1) THEN
			P=Z
			PP=ZZ
		ELSE
			BK=BKNUM/BKDEN
			P=BK*P+Z
			PP=BK*PP+ZZ
		END IF
		BKDEN=BKNUM 		!CALCULATE COEFFICIENT AK, NEW ITERATE X, NEW RESIDUALS R AND RR.
		CALL ATIMES(SA,P,Z,0)
		AKDEN=DOT_PRODUCT(Z,PP)
		AK=BKNUM/AKDEN
		CALL ATIMES(SA,PP,ZZ,1)
		X=X+AK*P
		R=R-AK*Z
		RR=RR-AK*ZZ
		CALL ASOLVE(SA,R,Z,0)	!SOLVE A ·Z = R AND CHECK STOPPING CRITERION.
		SELECT CASE(ITOL)
			CASE(1)
				ERR=SNRM(R,ITOL)/BNRM
			CASE(2)
				ERR=SNRM(Z,ITOL)/BNRM
			CASE(3:4)
				ZM1NRM=ZNRM
				ZNRM=SNRM(Z,ITOL)
				IF (ABS(ZM1NRM-ZNRM) > EPS*ZNRM) THEN
					DXNRM=ABS(AK)*SNRM(P,ITOL)
					ERR=ZNRM/ABS(ZM1NRM-ZNRM)*DXNRM
				ELSE
					ERR=ZNRM/BNRM
					CYCLE 	!ERROR MAY NOT BE ACCURATE, SO LOOP AGAIN.
				END IF
				XNRM=SNRM(X,ITOL)
				IF (ERR <= 0.5_DP*XNRM) THEN
					ERR=ERR/XNRM
				ELSE
					ERR=ZNRM/BNRM
					CYCLE 	!ERROR MAY NOT BE ACCURATE, SO LOOP AGAIN.

				END IF
		END SELECT
		WRITE (*,*) ’ ITER=’,ITER,’ ERR=’,ERR
		IF (ERR <= TOL) EXIT
	END DO
	END SUBROUTINE LINBCG
	!-----------------------------------------------------------
END MODULE NRSP90
